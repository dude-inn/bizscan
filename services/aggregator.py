# services/aggregator.py
from __future__ import annotations

from decimal import Decimal
from typing import Optional, Tuple, Dict, Any

from services.providers.base import CompanyProvider
from services.providers.ofdata import OFDataClient, OFDataClientError, OFDataServerTemporaryError
from services.mappers.ofdata import (
    map_company_ofdata,
    map_finance_ofdata,
    map_arbitration_ofdata,
    CompanyCard,
    FinanceSnapshot,
    ArbitrationSummary,
)
from utils.formatting import format_amount  # —Å–¥–µ–ª–∞–π helper: Decimal -> '1 234 567‚ÇΩ' (–∏–ª–∏ –ø–æ–¥–∫–ª—é—á–∏ —Å–≤–æ–π)
from utils.log import logger  # —Ç–≤–æ–π –ª–æ–≥–≥–µ—Ä; –µ—Å–ª–∏ –Ω–µ—Ç ‚Äî –∑–∞–º–µ–Ω–∏ –Ω–∞ logging.getLogger(__name__)
import re


def get_provider() -> CompanyProvider:
    """Return OFData provider only (DataNewton disabled)."""
    from services.providers.ofdata import API_KEY
    if not API_KEY or API_KEY == "your_ofdata_api_key_here":
        raise OFDataClientError("OFData selected but OFDATA_KEY is not configured")
    logger.info("üîç Using OFData provider")
    return OFDataClient()


def _detect_id_kind(s: str) -> Tuple[str, str]:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç ('inn'|'ogrn', value) –∏–ª–∏ ('', '') –µ—Å–ª–∏ –Ω–µ–≤–∞–ª–∏–¥–Ω–æ."""
    s = re.sub(r"\D+", "", s or "")
    if re.fullmatch(r"\d{10}|\d{12}", s):
        return "inn", s
    if re.fullmatch(r"\d{13}|\d{15}", s):
        return "ogrn", s
    return "", ""


async def fetch_company_profile(input_str: str) -> Dict[str, Any]:
    """
    Fetch complete company profile by INN/OGRN or name query
    
    Args:
        input_str: INN, OGRN, or company name
        
    Returns:
        Dict with company data and sources
    """
    # OFData only
    user_source = "ofdata"
    
    # Detect if input is INN/OGRN
    kind, value = _detect_id_kind(input_str)
    
    if kind:
        # Direct INN/OGRN lookup
        inn = value if kind == "inn" else None
        ogrn = value if kind == "ogrn" else None
    else:
        # Try name search via OFData
        provider = get_provider()
        inn, ogrn = provider.resolve_by_query(input_str)
        
        if not inn and not ogrn:
            return {
                "error": "–ö–æ–º–ø–∞–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –£—Ç–æ—á–Ω–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –ò–ù–ù/–û–ì–†–ù",
                "sources": _fmt_sources()
            }
    
    # Fetch data from provider
    provider = get_provider()
    
    try:
        # Get counterparty data with caching
        identifier = inn or ogrn
        cache_key = f"counterparty:{identifier}"
        
        # Try cache first
        from services.cache import get_cached, set_cached
        raw_card = await get_cached(user_source, "counterparty", identifier)
        
        if raw_card is None:
            # Cache miss - fetch from provider
            raw_card = provider.get_counterparty(inn=inn, ogrn=ogrn)
            await set_cached(user_source, "counterparty", identifier, raw_card)
        
        # Map using OFData mapper
        card = map_company_ofdata(raw_card)
        
        # Get financial data with caching
        try:
            raw_finance = await get_cached(user_source, "finance", identifier)
            if raw_finance is None:
                raw_finance = provider.get_finance(inn=inn, ogrn=ogrn)
                await set_cached(user_source, "finance", identifier, raw_finance)
            
            finances = map_finance_ofdata(raw_finance)
        except (DNClientError, DNServerTemporaryError, OFDataClientError, OFDataServerTemporaryError) as e:
            logger.warning("Finance data unavailable: %s", e)
            finances = []
        
        # Get paid taxes data with caching
        try:
            raw_taxes = await get_cached(user_source, "paid_taxes", identifier)
            if raw_taxes is None:
                raw_taxes = provider.get_paid_taxes(inn=inn, ogrn=ogrn)
                await set_cached(user_source, "paid_taxes", identifier, raw_taxes)
            
            # OFData may not support paid taxes - skip silently
            taxes = []
        except (OFDataClientError, OFDataServerTemporaryError) as e:
            logger.warning("Paid taxes data unavailable: %s", e)
            taxes = []
        
        # Get arbitration data with caching
        try:
            raw_arbitration = await get_cached(user_source, "arbitration", identifier)
            if raw_arbitration is None:
                raw_arbitration = provider.get_arbitration_cases(inn=inn, ogrn=ogrn)
                await set_cached(user_source, "arbitration", identifier, raw_arbitration)
            
            arbitration = map_arbitration_ofdata(raw_arbitration)
        except (OFDataClientError, OFDataServerTemporaryError) as e:
            logger.warning("Arbitration data unavailable: %s", e)
            arbitration = ArbitrationSummary(total=0, cases=[])
        
        return {
            "base": card,
            "finances": finances,
            "taxes": taxes,
            "arbitration": arbitration,
            "sources": _fmt_sources()
        }
        
    except (OFDataClientError, OFDataServerTemporaryError) as e:
        logger.error("Provider error: %s", e)
        return {
            "error": f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö: {e}",
            "sources": _fmt_sources()
        }


def _fmt_status(card: CompanyCard) -> str:
    code = card.status_code or "UNKNOWN"
    txt = card.status_text or ""
    mapping = {
        "ACTIVE": "‚úÖ –î–µ–π—Å—Ç–≤—É–µ—Ç",
        "LIQUIDATED": "‚õî –ü—Ä–µ–∫—Ä–∞—â–µ–Ω–∞",
        "NOT_ACTIVE": "‚ö†Ô∏è –ù–µ –¥–µ–π—Å—Ç–≤—É–µ—Ç",
        "UNKNOWN": "‚ùì –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
    }
    base = mapping.get(code, "‚ùì –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")
    if txt and txt not in base:
        return f"{base} ({txt})"
    return base


def _fmt_finances(fin_list: list[FinanceSnapshot]) -> str:
    if not fin_list:
        return "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö"
    lines = []
    # —É–ø–æ—Ä—è–¥–æ—á–∏–º –ø–æ –≥–æ–¥—É –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é
    fin_list = sorted(fin_list, key=lambda x: x.period)
    # –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 5 –ø–µ—Ä–∏–æ–¥–æ–≤
    if len(fin_list) > 5:
        fin_list = fin_list[-5:]
    for f in fin_list:
        rev = format_amount(f.revenue) if f.revenue is not None else "N/A"
        prof = format_amount(f.net_profit) if f.net_profit is not None else "N/A"
        assets = format_amount(f.assets) if f.assets is not None else "N/A"
        equity = format_amount(f.equity) if f.equity is not None else "N/A"
        liab_long = format_amount(f.liabilities_long) if f.liabilities_long is not None else "N/A"
        liab_short = format_amount(f.liabilities_short) if f.liabilities_short is not None else "N/A"
        lines.append(f"{f.period}: –≤—ã—Ä—É—á–∫–∞ {rev}, –ø—Ä–∏–±—ã–ª—å {prof}, –∞–∫—Ç–∏–≤—ã {assets}, –∫–∞–ø–∏—Ç–∞–ª {equity}, –¥–æ–ª–≥.–æ–±—è–∑. {liab_long}, –∫—Ä–∞—Ç–∫.–æ–±—è–∑. {liab_short}")
    return "\n".join(lines)


def _fmt_contacts(card: CompanyCard) -> str:
    contacts = getattr(card, "contacts", {}) or {}
    if not isinstance(contacts, dict):
        return "‚Äî"
    site = contacts.get("site") or contacts.get("website")
    emails = contacts.get("emails") or contacts.get("email") or []
    phones = contacts.get("phones") or contacts.get("tel") or []
    if isinstance(emails, str):
        emails = [emails]
    if isinstance(phones, str):
        phones = [phones]
    # normalize possible dict items to strings
    def _to_str_list(items):
        out = []
        for it in items or []:
            if isinstance(it, dict):
                val = it.get("value") or it.get("email") or it.get("phone") or it.get("number") or it.get("display")
                if val:
                    out.append(str(val))
            else:
                out.append(str(it))
        return out
    emails = _to_str_list(emails)
    phones = _to_str_list(phones)
    parts = []
    if site:
        if isinstance(site, dict):
            site_val = site.get("value") or site.get("url") or site.get("site")
            if site_val:
                parts.append(str(site_val))
        else:
            parts.append(str(site))
    if emails:
        parts.append("email: " + ", ".join(emails[:3]))
    if phones:
        parts.append("—Ç–µ–ª: " + ", ".join(phones[:3]))
    return "; ".join(parts) if parts else "‚Äî"


def _fmt_paid_taxes(items) -> str:
    if not items:
        return "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö"
    out = []
    for it in items:
        if not it.items:
            # –¥–∞—Ç–∞ –µ—Å—Ç—å ‚Äî –Ω–æ —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç
            out.append(f"{it.report_date}: ‚Äî")
            continue
        lines = "; ".join([f"{name} {format_amount(val)}" for name, val in it.items])
        if it.report_date:
            out.append(f"{it.report_date}: {lines}")
        else:
            out.append(lines)
    return "\n".join(out)


def _fmt_arbitration(ar: ArbitrationSummary) -> str:
    if ar.total == 0 or not ar.cases:
        return "–ù–µ—Ç –¥–µ–ª"
    lines = [f"–í—Å–µ–≥–æ –¥–µ–ª: {ar.total}"]
    for c in ar.cases[:10]:
        parts = [c.number]
        if c.date_start:
            parts.append(c.date_start)
        if c.role:
            parts.append(c.role)
        if getattr(c, "amount", None) is not None:
            parts.append(f"—Å—É–º–º–∞ {format_amount(c.amount)}")
        # court: prefer first instance if list provided
        court_name = None
        if c.instances and isinstance(c.instances, (list, tuple)) and len(c.instances) > 0:
            court_name = c.instances[0]
        elif c.court:
            court_name = c.court
        if court_name:
            parts.append(court_name)
        lines.append(" ‚Äî ".join(parts))
    return "\n".join(lines)


def _fmt_sources() -> str:
    # –ë–µ–∑ —É–ø–æ–º–∏–Ω–∞–Ω–∏—è –ø–æ—Å—Ä–µ–¥–Ω–∏–∫–∞. –¢–æ–ª—å–∫–æ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏.
    return (
        "–ï–ì–†–Æ–õ/–†–æ—Å—Å—Ç–∞—Ç; –ë—É—Ö–≥–∞–ª—Ç–µ—Ä—Å–∫–∞—è –æ—Ç—á—ë—Ç–Ω–æ—Å—Ç—å (–§–ù–° –ì–ò–† –ë–û); "
        "–§–ù–° ‚Äî –¥–∞–Ω–Ω—ã–µ –æ–± —É–ø–ª–∞—Ç–µ –Ω–∞–ª–æ–≥–æ–≤; –ö–∞—Ä—Ç–æ—Ç–µ–∫–∞ –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—ã—Ö –¥–µ–ª"
    )


def build_markdown_report(card, finances, taxes, arbitr) -> str:
    # –ê–¥—Ä–µ—Å/–û–ö–í–≠–î/—Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å –º–æ–≥—É—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–æ–≤–∞—Ç—å ‚Äî –∞–∫–∫—É—Ä–∞—Ç–Ω–æ –æ—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º
    address = card.address or "‚Äî"
    okved = card.okved or "‚Äî"
    head = f"{card.manager_name} ‚Äî {card.manager_post}" if (card.manager_name or card.manager_post) else "‚Äî"

    msme_line = "‚Äî"
    if card.is_msme is True:
        msme_line = "–Ø–≤–ª—è–µ—Ç—Å—è —Å—É–±—ä–µ–∫—Ç–æ–º –ú–°–ü"
    elif card.is_msme is False:
        msme_line = "–ù–µ —è–≤–ª—è–µ—Ç—Å—è —Å—É–±—ä–µ–∫—Ç–æ–º –ú–°–ü"

    from datetime import datetime
    today = datetime.now().strftime("%Y-%m-%d")
    md = []
    md.append(f"üßæ {card.name_full} ‚Ä¢ {card.name_short or ''} ‚Äî {today}")
    md.append("")
    md.append("**–†–µ–∫–≤–∏–∑–∏—Ç—ã**")
    short = f' ‚Ä¢ {card.name_short}' if card.name_short else ""
    md.append(f'{card.name_full}{short}')
    md.append(f'–ò–ù–ù {card.inn} ‚Ä¢ –û–ì–†–ù {card.ogrn or "‚Äî"}{f" ‚Ä¢ –ö–ü–ü {card.kpp}" if card.kpp else ""}')
    if card.registration_date:
        md.append(f"üìÖ –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è: {card.registration_date}")
    md.append(f"**–°—Ç–∞—Ç—É—Å:** {_fmt_status(card)}")
    md.append(f"üìç **–ê–¥—Ä–µ—Å:** {address}")
    md.append(f"üè∑Ô∏è **–û–ö–í–≠–î:** {okved}")
    md.append("")
    md.append("üßë‚Äçüíº **–†—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å**")
    md.append(head)
    md.append("")
    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ (–µ—Å–ª–∏ –µ—Å—Ç—å)
    if getattr(card, "opf", None) or getattr(card, "charter_capital", None):
        opf = getattr(card, "opf", None) or "‚Äî"
        cap = format_amount(card.charter_capital) if getattr(card, "charter_capital", None) is not None else "‚Äî"
        md.append("üè¢ **–û—Ä–≥. —Ñ–æ—Ä–º–∞ –∏ –∫–∞–ø–∏—Ç–∞–ª**")
        md.append(f"–û–ü–§: {opf}; –£—Å—Ç–∞–≤–Ω—ã–π –∫–∞–ø–∏—Ç–∞–ª: {cap}")
        md.append("")
    if getattr(card, "owners", None):
        try:
            owners = card.owners or []
            owner_lines = []
            for o in owners[:5]:
                if not isinstance(o, dict):
                    continue
                name = o.get("name") or o.get("–ù–∞–∏–º–ü–æ–ª–Ω") or o.get("–ù–∞–∏–º–°–æ–∫—Ä") or "‚Äî"
                share = None
                if o.get("–î–æ–ª—è") and isinstance(o.get("–î–æ–ª—è"), dict):
                    share = o["–î–æ–ª—è"].get("–ü—Ä–æ—Ü–µ–Ω—Ç")
                share = share or o.get("share") or o.get("percent")
                if share is not None:
                    owner_lines.append(f"{name} ‚Äî {share}%")
                else:
                    owner_lines.append(name)
            if owner_lines:
                md.append("üë• **–°–æ–±—Å—Ç–≤–µ–Ω–Ω–∏–∫–∏**")
                md.append("; ".join(owner_lines))
                md.append("")
        except Exception:
            pass
    if getattr(card, "tax_mode", None) or getattr(card, "workers_count", None):
        md.append("üèõÔ∏è **–ù–∞–ª–æ–≥–∏ –∏ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∏**")
        md.append(f"–†–µ–∂–∏–º: {getattr(card, 'tax_mode', None) or '‚Äî'}; –°–ß–†: {getattr(card, 'workers_count', None) or '‚Äî'}")
        md.append("")
    md.append("üìû **–ö–æ–Ω—Ç–∞–∫—Ç—ã**")
    md.append(_fmt_contacts(card))
    md.append("")
    if getattr(card, "predecessors", None) or getattr(card, "successors", None) or getattr(card, "negative_lists", None):
        flags = []
        if getattr(card, "predecessors", None):
            flags.append("–ø—Ä–∞–≤–æ–ø—Ä–µ–¥—à–µ—Å—Ç–≤–µ–Ω–Ω–∏–∫–∏")
        if getattr(card, "successors", None):
            flags.append("–ø—Ä–∞–≤–æ–ø—Ä–µ–µ–º–Ω–∏–∫–∏")
        neg = getattr(card, "negative_lists", None) or {}
        if isinstance(neg, dict) and any(bool(v) for v in neg.values()):
            flags.append("–Ω–µ–≥–∞—Ç–∏–≤–Ω—ã–µ —Å–ø–∏—Å–∫–∏")
        if flags:
            md.append("‚ö†Ô∏è **–û—Å–æ–±—ã–µ –æ—Ç–º–µ—Ç–∫–∏**")
            md.append(", ".join(flags))
            md.append("")
    md.append("üß© **–ú–°–ü**")
    md.append(msme_line)
    md.append("")
    md.append("üìä **–§–∏–Ω–∞–Ω—Å—ã**")
    md.append(_fmt_finances(finances))
    md.append("")
    md.append("üí∞ **–£–ø–ª–∞—á–µ–Ω–Ω—ã–µ –Ω–∞–ª–æ–≥–∏**")
    md.append(_fmt_paid_taxes(taxes))
    md.append("")
    md.append("üìÑ **–ê—Ä–±–∏—Ç—Ä–∞–∂**")
    md.append(_fmt_arbitration(arbitr))
    md.append("")
    
    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –±–ª–æ–∫ –¥–ª—è Gamma –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º –≤ —Ö–µ–Ω–¥–ª–µ—Ä–µ
    
    # –î–æ–±–∞–≤–ª—è–µ–º –±–ª–æ–∫ –¥–ª—è Gamma (–æ–ø–∏—Å–∞—Ç–µ–ª—å–Ω–∞—è —Å–µ–∫—Ü–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–∞—Ä—Ç–æ—á–∫–∏/—Ä–µ–µ—Å—Ç—Ä–æ–≤)
    try:
        from services.enrichment.official_sources import build_official_links
        from services.enrichment.openai_gamma_enricher import generate_gamma_section
        # –°–æ–±–∏—Ä–∞–µ–º –±–∞–∑–æ–≤—ã–µ –ø–æ–ª—è –∫–æ–º–ø–∞–Ω–∏–∏
        company_dict = {
            "name_full": card.name_full,
            "name": card.name_short,
            "inn": card.inn,
            "ogrn": card.ogrn,
            "okved": card.okved,
            "opf": getattr(card, "opf", None),
            "status_code": getattr(card, "status_code", None),
            "status_text": getattr(card, "status_text", None),
            "registration_date": getattr(card, "registration_date", None),
            "address": card.address,
            "manager_name": getattr(card, "manager_name", None),
            "manager_post": getattr(card, "manager_post", None),
            "charter_capital": getattr(card, "charter_capital", None),
            "owners": getattr(card, "owners", None),
            "tax_mode": getattr(card, "tax_mode", None),
            "workers_count": getattr(card, "workers_count", None),
            "contacts": getattr(card, "contacts", None),
            "predecessors": getattr(card, "predecessors", None),
            "successors": getattr(card, "successors", None),
            "negative_flags": getattr(card, "negative_lists", None),
        }
        # –§–∏–Ω–∞–Ω—Å—ã –∫–æ–º–ø–∞–∫—Ç: –ø–æ—Å–ª–µ–¥–Ω–∏–π –ø–µ—Ä–∏–æ–¥
        fin_digest = {}
        if finances:
            last = sorted(finances, key=lambda x: x.period)[-1]
            fin_digest = {
                "last_year": last.period,
                "revenue": last.revenue,
                "profit": last.net_profit,
                "assets": last.assets,
                "equity": last.equity,
            }
        company_dict["finances_digest"] = fin_digest
        # Official links
        site = None
        if isinstance(getattr(card, "contacts", None), dict):
            c = card.contacts or {}
            site = c.get("site") or c.get("website")
            if isinstance(site, dict):
                site = site.get("value") or site.get("url") or site.get("site")
        official_links = build_official_links(card.inn, card.ogrn, site)
        gamma_md = generate_gamma_section(company_dict, official_links)
        if gamma_md:
            md.append("### üåê –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ (–¥–ª—è Gamma)")
            md.append(gamma_md)
            md.append("")
    except Exception:
        # –ï—Å–ª–∏ –æ–±–æ–≥–∞—â–µ–Ω–∏–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ ‚Äî –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –±–µ–∑ –æ—à–∏–±–∫–∏
        pass

    # –î–∏—Å–∫–ª–µ–π–º–µ—Ä
    md.append("–î–∞–Ω–Ω—ã–µ —Å–æ–±—Ä–∞–Ω—ã –∏–∑ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã—Ö –æ—Ç–∫—Ä—ã—Ç—ã—Ö —Ä–µ–µ—Å—Ç—Ä–æ–≤ –†–§ (–ï–ì–†–Æ–õ/–†–æ—Å—Å—Ç–∞—Ç, –§–ù–° ‚Äî –ì–ò–† –ë–û, –ö–ê–î).")
    return "\n".join(md)


async def fetch_company_report_markdown(query: str) -> str:
    """Generate markdown report for company"""
    profile = await fetch_company_profile(query)
    
    if "error" in profile:
        return profile["error"]
    
    return build_markdown_report(
        profile["base"],
        profile["finances"], 
        profile["taxes"],
        profile["arbitration"]
    )
